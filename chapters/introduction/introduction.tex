
% !TeX spellcheck = en_US


\chapter{Notes}


\url{https://climbtheladder.com/10-database-change-management-best-practices/}
\url{https://medium.com/capital-one-tech/database-migrations-with-flyway-16b6478e55a6}


In practice each change should be written as an update script, in a way that each individual and atomic change can be run against the database. This change file can be commited and applied in CI processes.\\

It's also important to make sure everyone can see the progress of the changes, so the team (including the DBA) can understand which changes are pending, their testing status, and which schema changes have been applied to the various production and non-production shared databases. This can be achieved by\\

\chapter{Introduction}


\section{Problem Statement and Benefits}%
 
 \marginpar{Motivation\\ \cite{techopedia2022}, \cite{Choudhry2018}, \cite{Parsick2018}}%
 In the last 20 years, agile approaches have spread in their popularity. One principle of agile methods is, how to deal with change. This has changed massively compared to previous not agile methods. If you are operating agile, you want to allow changes, even late in the project. But in contrast, the database community has traditionally considered database design to be something that needs to be planned in advance.\\
 
 In this complex and agile company environment, it is very hard to keep track of the database changes. Handling relational database changes requires special consideration and offer different challenges than deploying classical software. Database systems suffer from problems such as untracked changes, overwritten code, data-loss or data mix-up. Such shortcomings applied to the production database can be a major risk. Manual modification of database structures can be very time-consuming and error-prone. Nobody knows which database scripts have been migrated on which database instances. 
 Without a clearly defined process, database migration scripts are recorded for example on release notes or ticket systems..
In addition, no one may know how the test database differs from the production database.\\
 
 For that reason, these migrations are best done automatically so it does not come to downtime or errors. A proper database change management ensures that changes to a database are controlled and safe. According to \cite{ManageForce2016}, 80\% of unplanned database downtime id due database changes.
Developers need a good strategy, how to apply changes to the same database environment.
This requires a best practices strategy on how to deal with different users, branches and applications. Using a proper management system can prevent a developer of running into a very annoying \textit{Column not found} error.\\

 
\marginpar{Benefits}%
With the problems and shortcomings mentioned above, it is very useful to implement certain automatism or use so-called change management tools in the deployment pipeline.
\cite{Dillon2022}, \cite{Robles2021} and \cite{Fritchey2022} present the benefits a change management tool should provide or at least make it easier to use. These benefits are summarized in the following.

\begin{enumerate}
	\item Unique identification of all migrations and recording in a migration history table
    \item Automatically deploy scripts and keep track whether they are already applied or not
    \item Branching and merging for development in teams
    \item Embed easily into products or build tools
    \item Make it easy to undo or revert changes without requiring a restore
    \item Reproduce schema changes across multiple environments and auditing of these changes
    \item Provide automation so you can do schema changes automatically without manual effort
    \item An additional backup of the code that defines the database
\end{enumerate}


Furthermore, a migration can be used as single source of truth for the actual production schemas. This becomes very handy, as soon as one has to manage and update multiple database environments with different deployment states.

\marginpar{Context}%
This seminar thesis focuses on database migrations in the context of schema migrations.  Other database migrations such as moving a database to a different platform or a cloud are not considered in the context of this work.

\section{State of the Art}%
\subsection{DevOps strategies}
\marginpar{Change\\ management strategies\\ \cite{GoogleDevOps2022}, \cite{Piairo2018}}%
In most organizations, the way in which database changes are handled is different. There are the following common scenarios:

\begin{enumerate}
	\item \textit{Database changes are not included in the deployment pipeline}\\
	If changes in the database are not included in the pipeline, most migrations are performed manually which is resulting in risks and ultimately into costs. Not including the database changes at all lead to lacks in traceability and promotes the fear of every change.
	
	\item \textit{Database and application changes have a different deployment process}\\
	Software developers use continuous delivery to manage their deployment of the software. In a nowadays modern agile environment, the demand for techniques that support this agile processes are desired. A lot of teams use similar techniques when it comes to database change management and add their database changes as scripts in version control tools in a separate pipeline. Most developers know very well how to use the tools from software development and can apply these version control techniques for their database environment. If a database has an encapsulate pipeline to the application, this means that the application development team and the database administrator have to keep synchronized. As a result, agile delivery processes become slowed down by database deployment and synchronization with the application.
	
	Team members, including DBAs, need to be able to see how changes are progressing so they can know what changes are planned, how their testing is going, and which schema changes have been implemented in production databases.
	
	\item \textit{Database and application share a deployment process}
	According to  \cite{GoogleDevOps2022}, this is the best pratice method which can be achieved by this:
	\begin{itemize}
		\item Keeping all database schema changes in version control, together with the application code the schema belongs to
		\item Using a tool that records which changes have been run against which environments, and what the results were.
	\end{itemize}
	These practices also ensure that there is a canonical source of truth for all changes and make the change history easily accessible for auditing purposes.

\end{enumerate}



\subsection{Deployment workflows}
"All databases changes are migrations" \cite{Robles2021}\\
See \cite{Piairo2018}, \cite{Sadalage2016}

\marginpar{Source control}%
"All database artifacts are version controlled with application code"

\marginpar{State based vs migration based}%

\marginpar{Deployment pipelines scenarios}%


\subsection{Best Practices for database migrations}%
\marginpar{Best practices methods \cite{F5works2017}, \cite{Langan2022}, \cite{Parsick2018}}%

Regardless of what strategy or tools a developer needs, there are certain best practices that simplify dealing with database changes.

\begin{itemize}
	\item Use a version control system\\
	Whether you use a migration tool or not it make sense to version control all artefacts like DDL, DML, test data, configurations, functions etc with a version control system like Git
	\item Atomic changes: For example, when there is code change that requires changing 2 database tables plus patching existing data, there should be at least 3 scripts
	\item Naming convention: \\
	A team or company should agree on a naming convention for the migration files. It is recommended to use an ascending naming convention, for example with increasing file names.
	\begin{lstlisting}[caption=Increasing file names]
		001_add_discounted_amount_to_products.sql
		002_add_total_amount_to_orders.sql
		003_patch_products_default_discounted_amount.sql
	\end{lstlisting}
	
	It would be even better if the date and time were included. This way the current index does not have to be checked, because the changes to an identical naming are very small.
	\begin{lstlisting}[caption=Timestamps]
		20170517080001_add_discounted_amount_to_products.sql
		20170517081501_add_total_amount_to_orders.sql
		20170517083601_patch_products_default_discounted_amount.sql
	\end{lstlisting}
	\item Make sure to track all database changes\\
	Everyone should be able to see the latest change and history
	\item Store current schema version number in database\\
	To check weather the most recent version is deployed
	\item Automate the deployment process\\
	Manual changes can easily lead to mistakes and need manual rollbacks. Therefore use an automation and migration tool that can avoid costly mistakes and have the ability to roll back.
	\item Test changes\\
	Every migration or changes has to be tested
	\item Document changes 
\end{itemize}

\section{Available Tools}%
%This section will provide an overview of available change management tools.
%The list of tools should include the available programming languages, price / availability
%and the main advantage over their competitors.
There exists tons 


migrate (Go)\\
alembic (Python)\\
Active Record Migrations (Ruby on Rails)\\
dbup (.NET)\\
Entity Framework Migrations (.NET)\\
Laravel Migrations (PHP)\\
Flyway (platform-independent)\\
Liquibase (platform-independent)\\
DBdeploy \url{http://dbdeploy.com}\\
Yoyo \url{https://ollycope.com/software/yoyo/latest/}\\
Phinx \url{https://book.cakephp.org/phinx/0/en/migrations.html}\\
DBmaestro \url{https://www.dbmaestro.com/for-devops}\\
Django \url{https://docs.djangoproject.com/en/1.11/topics/migrations/}



\section{Overview}%
This section gives a overview of the thesis.




\newpage